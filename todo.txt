Look in /pm-template by default.
But content.md is always sourced from the pm-src folder itself.
    If "content.md" was invoked but no content.md was provided, a lorem ipsum text will be inserted instead.
"template" can be defined in the front matter.

{{ range $entry := getEntries "/writing" "lastModified DESC" }}
    {{ $entry.name }}
    {{ $entry.lastModified }}
    {{ $entry.title }}
    {{ $entry.summary }}
    {{ $entry.by }}
    {{ $entry.date }}
    {{ $entry.published }}
{{ end }}
{{ $data := load "github.com/bokwoon95/plainsimple/linode_header.toml" }}
    first search in pm-src/github.com/bokwoon95/plainsimple/linode_header.toml, then pm-template/github.com/bokwoon95/plainsimple/linode_header.toml
    this allows users to copy paste linode_header.toml from pm-template into pm-src, then make the necessary changes.
    so all of a sudden templates can use load as well, complete with user-tweakable menu bars and shit.
{{ range $data.products }}
{{ end }}
{{ range $data.pricing }}
{{ end }}
{{ range $data.career }}
{{ end }}
{{ link "/abc-def" }} # adds tildePrefix and langCode to the link.
What if you need a different sort order?

being able to filter on $entry tags essentially gives you taxonomies for free.

{{ $pages := getPages "/writing" "ORDER BY name ASC, lastModifier DESC" }}

pm.template() must hardcode the domain, subdomain, tildePrefix and langcode into the template functions.
This is because each fully-assembled template already makes assumptions about which language-specific template are used e.g. content.en.md
{{ coalesce lang.homeHero "" }}
{{ getPages .PathName "-sort" "-filter" }}

{{ $lang := load "github.com/bokwoon95/plainsimple/lang.toml" }}
{{ or lang.title $lang.title | safeHTML }}
rather than using coalesce to provide a lang default, templates are able to define their own lang.toml which will be used as the default fallback (means lang is first populated from the template's)
TODO: darn, the problem with using coalesce to provide language defaults is that you have to define a default at every call site, as compared to aggregating it into a toml file where it can be reused over and over.
TODO: darn, the problem with using a theme-specific lang.toml is that... a theme doesn't really exist. It's directories all the way down. The lang.toml could be in any directory. Which directory should we honor? What if there are multiple themese referenced?
TODO: What if themes themselves want to provide their own translations? Their own en.toml, zh.toml? Where does it go?

Q: What is the type of the first argument passed to getPages?
A: The domain, subdomain, tildePrefix and langCode are all baked into the templates and template functions. No first argument is needed.
Do I need to expose domain, subdomain, tildePrefix and langCode in the template itself? Is it ever relevant to display that in the template? if so, add it to the site.domain, site.subdomain, site.tildePrefix, langCode functions.

Q: What is the type passed to each ExecuteTemplate?
A: .PathName, that's about it. No, even pathName should be a template function.

Q: What type does getEntries return?
A:

Baked in:
Domain
Subdomain
TildePrefix
LangCode

.PageContext.Domain
.PageContext.Subdomain
.PageContext.LangCode
.Content.title

[content.toml]
title
by (By <author>)
date (<date>)
tags (Tags: <tags>...)
published (Published <date>)

{{ getEntries .PageContext "" }}

[content.md]
+++
title = "How To Train Your Dragon"
by = "bokwoon"
date = 2010-05-21
published = 2010-05-30
tags: ["python", "", "", ""]
template: "post.html"
+++
Implicit attributes (should the user choose to display them):
- Title
- Date
- Published
- Summary

Plugins can:
- Register template functions.
    - plugin order matters, the first plugin to register a template function name wins.
- Register handlers (for the user to use).
- Copy their assets into the pm-template folder (for the user to use)
- Register a plugin root handler.

A comment plugin can essentially create the comments table, add a function handler

if it's a base file, search in both the current directory then in pm-template

page {
    name
    lastModified
    path
    title
    by
    date
    published
    tags
    summary
}

getPages -recursive -sort -filter -tags

{{ $pages := getPages .URL
    "-pathname" "/abcdefg"
    "-recursive"
    "-sort" "name desc, lastModified, title"
}}

{{ $pages := getPages .URL "-path=/" "-recurse" }}
{{ range $page := $pages }}
{{ end }}

getPages -host bokwoon.github.com -path

plugins can register template commands
plugins can register handler functions
plugins can provide a custom handler under /pm-plugin/github.com/user/repo
    intended for automatic data handling

{{ cmd "index" }}
{{ cmd "github.com/user/repo:funcs" }}

```
How To Train Your Dragon
2010 March 25
Published 2010 March 30

Hiccup, a Viking, must kill a dragon to mark his passage into manhood and be initiated into his tribe. However, he ends up doing the exact opposite by befriending a deadly dragon, Night Fury.
```

pagemanager manager (pmm)
It is a fyne.io application.
It can browse the list of registered plugins at pagemanager.org.
It can automatically download go and git on the user's system.
It can recompile the user's main.go and import.go to produce a runnable binary.
It can run the pagemanager binary and manage its lifecycle (start up, shut down).
If no SQL dsn is provided, it falls back to spinning up an SQLite database in the data directory.
.gitignore: pagemanager.db, pagemanager.exe, pagemanager
