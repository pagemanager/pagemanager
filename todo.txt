Look in /pm-template by default.
But content.md is always sourced from the pm-src folder itself.
    If "content.md" was invoked but no content.md was provided, a lorem ipsum text will be inserted instead.
"template" can be defined in the front matter.
maybe content.md isn't the only thing read from the current directory. All non-directory .md files are sourced from the current directory directory.
    why? so users can override multiple blocks in their templates (but usually it's just content.md).
    .md accepts all html so we can use .md as an indication that a template is an overrideable block.

a database and an fs.FS
How to protect sensitive config information? Should it all be stored on the fs.FS?

The problem with providing a DSN is that each plugin ends up using their own pool of connections. If you have hundreds of plugins, you have to multiply the number of pooled connections by a hundred. It may be more efficient to pass an *sql.DB instance to each plugin so that the pool can be reused. The worrying thing is that if this pattern applies to other third party depedencies we may need to figure out how to pass in third party depedencies to the plugin as well. Example third party dependencies:
- A redis server
- An elasticsearch server

About dsn.txt: pagemanager cannot construct an SQLite database from an fs.FS alone.

type Config struct {
    Mode     string // 0 (readonly) | 1 (local) | 2 (live)
    FS       fs.FS
    DB1      *sql.DB
    DB2      *sql.DB
    DB3      *sql.DB
    Handlers map[string]http.Handler
}

pmm is responsible for setting offline mode as the default so that non-technical users can immediately start authoring their website on localhost. Otherwise if you start the server from the commandline using ./pagemanager the server will start in readonly where you can only make changes by directly authoring files in pm-src with a text editor.

-pm-mode (local | live)
-pm-dir
-pm-dsn1
-pm-dsn2
-pm-dsn3

How do handlers and sources get access to the mode, filesystem and database?
TODO: the hardest part about this is that if plugins register handlers and sources at init time, then plugins need to be able to access the FS and DB at init time (so that their custom structs can get populated).
I could mandate plugins to inject their FS and DB dependencies via closures, but then that would discount being able to use instantiate the plugin types directly and using them instead.

If no FS is provided:
- Check if -pm-dir was set.
- Check if current directory contains pm-src and pm-template (if so, $PWD is $DATA_DIR).
- Check if current directory contains pagemanager-data (if so, $PWD/pagemanager-data is $DATA-DIR).
- Else fall back to $HOME/pagemanager-data.

If no DB is provided:
- Check if -pm-dsn1 was set.
- Else fall back to an SQLite database created in the inferred $DATA_DIR.
    - If $DATA_DIR was not inferred (i.e. an FS was passed in), return an error saying no database was provided.

"Register a template data source."

{{ $entries := source "github.com/pagemanager/pagemanager.Index" "lastModified DESC" }}

{{ range $entry := getEntries "/writing" "lastModified DESC" }}
    {{ $data := load (pathJoin $entry "data.toml") }}
    {{ $entry.name }}
    {{ $entry.lastModified }}
    {{ $entry.title }}
    {{ $entry.summary }}
    {{ $entry.by }}
    {{ $entry.date }}
    {{ $entry.published }}
{{ end }}
{{ $data := load "github.com/bokwoon95/plainsimple/linode_header.toml" }}
    first search in pm-src/github.com/bokwoon95/plainsimple/linode_header.toml, then pm-template/github.com/bokwoon95/plainsimple/linode_header.toml
    this allows users to copy paste linode_header.toml from pm-template into pm-src, then make the necessary changes.
    so all of a sudden templates can use load as well, complete with user-tweakable menu bars and shit.
{{ range $data.products }}
{{ end }}
{{ range $data.pricing }}
{{ end }}
{{ range $data.career }}
{{ end }}
{{ pathJoin domain subdomain tildePrefix langCode "/abcdef" }}
templates can do this, but markdown content cannot. In markdown you have to hardcode the domain, subdomain and tildePrefix into a link. with markdown it's not really a problem because they are already selected based on the current langCode so you don't ever have to think about it (each content.md already operates with an implicit langCode in the context).
What if you need a different sort order?
oh no this is awful. I have to provide some way for markdown to automatically inject the domain, subdomain, tildePrefix and langCode into their links. Either I crawl all links in both markdown and html and convert

being able to filter on $entry tags essentially gives you taxonomies for free.

{{ $pages := getPages "/writing" "ORDER BY name ASC, lastModifier DESC" }}

pm.template() must hardcode the domain, subdomain, tildePrefix and langcode into the template functions.
This is because each fully-assembled template already makes assumptions about which language-specific template are used e.g. content.en.md
{{ coalesce lang.homeHero "" }}
{{ getPages .PathName "-sort" "-filter" }}

{{ $lang := load "github.com/bokwoon95/plainsimple/lang.toml" }}
{{ or lang.title $lang.title | safeHTML }}
rather than using coalesce to provide a lang default, templates are able to define their own lang.toml which will be used as the default fallback (means lang is first populated from the template's)
TODO: darn, the problem with using coalesce to provide language defaults is that you have to define a default at every call site, as compared to aggregating it into a toml file where it can be reused over and over.
TODO: darn, the problem with using a theme-specific lang.toml is that... a theme doesn't really exist. It's directories all the way down. The lang.toml could be in any directory. Which directory should we honor? What if there are multiple themese referenced?
TODO: What if themes themselves want to provide their own translations? Their own en.toml, zh.toml? Where does it go?
ACTUALLY: load has to respect the langCode. So, if langCode is en then lang.en.toml should be searched first, followed by lang.toml. This is so that people who are using custom data to drive menu bars can provide language-specific translations for each menu bar item. That way you don't even need a dedicated lang function anymore, the user just loads a custom toml file as usual. And it will the corresponding toml data in. Then just use $lang.<variable> for your i18n.

Q: What is the type of the first argument passed to getPages?
A: The domain, subdomain, tildePrefix and langCode are all baked into the templates and template functions. No first argument is needed.
Do I need to expose domain, subdomain, tildePrefix and langCode in the template itself? Is it ever relevant to display that in the template? if so, add it to the site.domain, site.subdomain, site.tildePrefix, langCode functions.

Q: What is the type passed to each ExecuteTemplate?
A: .PathName, that's about it. No, even pathName should be a template function.

Q: What type does getEntries return?
A:

Baked in:
Domain
Subdomain
TildePrefix
LangCode

.PageContext.Domain
.PageContext.Subdomain
.PageContext.LangCode
.Content.title

[content.toml]
title
by (By <author>)
date (<date>)
tags (Tags: <tags>...)
published (Published <date>)

{{ getEntries .PageContext "" }}

[content.md]
+++
title = "How To Train Your Dragon"
by = "bokwoon"
date = 2010-05-21
published = 2010-05-30
tags: ["python", "", "", ""]
template: "post.html"
+++
Implicit attributes (should the user choose to display them):
- Title
- Date
- Published
- Summary

Plugins can:
- Register data sources. ("github.com/pagemanager/pagemanager.index" is a custom data source)
    - plugin order matters, the first plugin to register a template function name wins.
- Register handlers (for the user to use).
- Copy their templates into the pm-template folder (for the user to use)
- Register a plugin root handler.

A comment plugin can essentially create the comments table, add a function handler

if it's a base file, search in both the current directory then in pm-template

page {
    name
    lastModified
    path
    title
    by
    date
    published
    tags
    summary
}

getPages -recursive -sort -filter -tags

{{ $pages := getPages .URL
    "-pathname" "/abcdefg"
    "-recursive"
    "-sort" "name desc, lastModified, title"
}}

{{ $pages := getPages .URL "-path=/" "-recurse" }}
{{ range $page := $pages }}
{{ end }}

getPages -host bokwoon.github.com -path

plugins can register template commands
plugins can register handler functions
plugins can provide a custom handler under /pm-plugin/github.com/user/repo
    intended for automatic data handling

{{ cmd "index" }}
{{ cmd "github.com/user/repo:funcs" }}

```
How To Train Your Dragon
2010 March 25
Published 2010 March 30

Hiccup, a Viking, must kill a dragon to mark his passage into manhood and be initiated into his tribe. However, he ends up doing the exact opposite by befriending a deadly dragon, Night Fury.
```

pagemanager manager (pmm)
It is a fyne.io application.
It can browse the list of registered plugins at pagemanager.org.
It can automatically download go and git on the user's system.
It can recompile the user's main.go and import.go to produce a runnable binary.
It can run the pagemanager binary and manage its lifecycle (start up, shut down).
If no SQL dsn is provided, it falls back to spinning up an SQLite database in the data directory.
.gitignore: pagemanager.db, pagemanager.exe, pagemanager
